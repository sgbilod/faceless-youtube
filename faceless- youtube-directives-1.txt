<artifact identifier="copilot-phase1-assessment" type="application/vnd.ant.code" language="markdown" title="Copilot Directive: Project Assessment & Cleanup">
# COPILOT DIRECTIVE: FACELESS YOUTUBE AUTOMATION - PHASE 1 ASSESSMENT
Target: GitHub Copilot Agent (Claude Sonnet 4.5)
Phase: Project Assessment & Pre-Packaging Cleanup
Priority: CRITICAL - Foundation for deployment

🎯 MISSION OBJECTIVES

Assess Current State: Verify all components are functional and properly connected
Identify Issues: Find all bugs, missing dependencies, broken paths, and integration failures
Clean & Consolidate: Fix critical issues preventing packaging
Prepare for Packaging: Create unified startup system


📋 TASK 1: PROJECT STRUCTURE VERIFICATION [TASK-VERIFY-001]
1.1 Map Current Directory Structure
Execute this analysis:
bash# From project root (C:\FacelessYouTube)
tree /F /A > project_structure.txt
Then create a comprehensive inventory:
markdown# PROJECT_INVENTORY.md

## Directory Structure
[Paste tree output]

## Python Files Inventory
- Total .py files: [COUNT]
- Core modules: [LIST]
- Services: [LIST]
- API routes: [LIST]
- Missing __init__.py: [LIST]

## Frontend Files Inventory  
- Total .js/.jsx files: [COUNT]
- Pages: [LIST]
- Components: [LIST]
- API clients: [LIST]

## Configuration Files
- .env files: [LIST]
- Config YAML/JSON: [LIST]
- Docker files: [LIST]

## Documentation Files
- Total .md files: [COUNT]
- Up-to-date: [LIST]
- Outdated: [LIST]

## Asset Files
- Videos: [COUNT] files, [SIZE] total
- Audio: [COUNT] files, [SIZE] total
- Fonts: [COUNT] files
- Templates: [COUNT] files

## Database Files
- Migration scripts: [COUNT]
- Seed data: [LIST]
- Schema definitions: [LIST]

📋 TASK 2: DEPENDENCY AUDIT [TASK-DEPS-002]
2.1 Python Dependencies
Create: dependency_audit.md
python# Run this script to audit Python dependencies

import pkg_resources
import subprocess
import sys

def audit_dependencies():
    """Audit all Python dependencies and check for issues."""
    
    # 1. List installed packages
    installed = {pkg.key: pkg.version for pkg in pkg_resources.working_set}
    
    # 2. Parse requirements.txt
    required = {}
    try:
        with open('requirements.txt', 'r') as f:
            for line in f:
                if '==' in line:
                    pkg, ver = line.strip().split('==')
                    required[pkg.lower()] = ver
    except FileNotFoundError:
        print("⚠️ requirements.txt not found!")
        return
    
    # 3. Check for mismatches
    print("\n## DEPENDENCY STATUS\n")
    
    missing = []
    mismatched = []
    
    for pkg, req_ver in required.items():
        if pkg not in installed:
            missing.append(f"❌ {pkg}=={req_ver} - NOT INSTALLED")
        elif installed[pkg] != req_ver:
            mismatched.append(
                f"⚠️ {pkg}: Required {req_ver}, Installed {installed[pkg]}"
            )
        else:
            print(f"✅ {pkg}=={req_ver}")
    
    if missing:
        print("\n### MISSING PACKAGES:\n")
        for pkg in missing:
            print(pkg)
    
    if mismatched:
        print("\n### VERSION MISMATCHES:\n")
        for pkg in mismatched:
            print(pkg)
    
    # 4. Check for unused packages
    print("\n### POTENTIALLY UNUSED:\n")
    for pkg in installed:
        if pkg not in required:
            print(f"🔍 {pkg} - Not in requirements.txt")

if __name__ == "__main__":
    audit_dependencies()
2.2 Node Dependencies
bashcd dashboard
npm list --depth=0 > npm_packages.txt
npm outdated > npm_outdated.txt
Analyze:

Security vulnerabilities: npm audit
Unused dependencies: Check package.json vs actual imports


📋 TASK 3: CONFIGURATION CONSOLIDATION [TASK-CONFIG-003]
3.1 Create Master Configuration System
File: src/config/master_config.py
python"""
Master Configuration System
Consolidates all configuration sources into single source of truth.
"""

from pathlib import Path
from typing import Optional, Dict, Any
from pydantic import BaseSettings, Field
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

class DatabaseConfig(BaseSettings):
    """Database connection settings."""
    
    postgres_host: str = Field(default="localhost", env="DB_HOST")
    postgres_port: int = Field(default=5432, env="DB_PORT")
    postgres_user: str = Field(default="postgres", env="DB_USER")
    postgres_password: str = Field(default="", env="DB_PASSWORD")
    postgres_db: str = Field(default="faceless_youtube", env="DB_NAME")
    
    mongodb_host: str = Field(default="localhost", env="MONGO_HOST")
    mongodb_port: int = Field(default=27017, env="MONGO_PORT")
    mongodb_db: str = Field(default="faceless_youtube", env="MONGO_DB")
    
    redis_host: str = Field(default="localhost", env="REDIS_HOST")
    redis_port: int = Field(default=6379, env="REDIS_PORT")
    redis_db: int = Field(default=0, env="REDIS_DB")
    
    @property
    def postgres_url(self) -> str:
        """Get PostgreSQL connection URL."""
        return (
            f"postgresql://{self.postgres_user}:{self.postgres_password}@"
            f"{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )
    
    @property
    def mongodb_url(self) -> str:
        """Get MongoDB connection URL."""
        return f"mongodb://{self.mongodb_host}:{self.mongodb_port}/{self.mongodb_db}"


class PathConfig(BaseSettings):
    """File system paths."""
    
    project_root: Path = Field(default=Path(__file__).parent.parent.parent)
    
    # Asset paths
    assets_dir: Path = Field(default=project_root / "assets")
    video_assets: Path = Field(default=assets_dir / "videos")
    audio_assets: Path = Field(default=assets_dir / "audio")
    fonts_dir: Path = Field(default=assets_dir / "fonts")
    
    # Output paths
    output_dir: Path = Field(default=project_root / "output_videos")
    temp_dir: Path = Field(default=project_root / "temp")
    cache_dir: Path = Field(default=project_root / "cache")
    
    # Script storage
    scripts_dir: Path = Field(default=project_root / "scripts")
    
    # Token storage
    tokens_dir: Path = Field(default=project_root / "youtube_tokens")
    
    def ensure_directories(self):
        """Create all required directories if they don't exist."""
        for field_name in self.__fields__:
            path = getattr(self, field_name)
            if isinstance(path, Path) and field_name != 'project_root':
                path.mkdir(parents=True, exist_ok=True)


class APIConfig(BaseSettings):
    """External API credentials."""
    
    # YouTube
    youtube_client_secrets: Path = Field(
        default=Path("client_secrets.json"),
        env="YOUTUBE_CLIENT_SECRETS"
    )
    
    # Pexels
    pexels_api_key: Optional[str] = Field(default=None, env="PEXELS_API_KEY")
    
    # Pixabay
    pixabay_api_key: Optional[str] = Field(default=None, env="PIXABAY_API_KEY")
    
    # Ollama
    ollama_host: str = Field(default="localhost", env="OLLAMA_HOST")
    ollama_port: int = Field(default=11434, env="OLLAMA_PORT")
    ollama_model: str = Field(default="mistral", env="OLLAMA_MODEL")
    
    # OpenAI (optional)
    openai_api_key: Optional[str] = Field(default=None, env="OPENAI_API_KEY")
    
    # ElevenLabs (optional)
    elevenlabs_api_key: Optional[str] = Field(default=None, env="ELEVENLABS_API_KEY")


class ApplicationConfig(BaseSettings):
    """Main application settings."""
    
    app_name: str = "Faceless YouTube Automation"
    app_version: str = "2.0.0"
    debug: bool = Field(default=False, env="DEBUG")
    
    # API settings
    api_host: str = Field(default="0.0.0.0", env="API_HOST")
    api_port: int = Field(default=8000, env="API_PORT")
    api_workers: int = Field(default=4, env="API_WORKERS")
    
    # Frontend settings
    frontend_port: int = Field(default=3000, env="FRONTEND_PORT")
    
    # Security
    secret_key: str = Field(
        default="CHANGE_THIS_IN_PRODUCTION",
        env="SECRET_KEY"
    )
    cors_origins: list = Field(
        default=["http://localhost:3000"],
        env="CORS_ORIGINS"
    )
    
    # Performance
    max_concurrent_jobs: int = Field(default=2, env="MAX_CONCURRENT_JOBS")
    cache_ttl: int = Field(default=3600, env="CACHE_TTL")


class MasterConfig:
    """
    Master configuration object consolidating all settings.
    
    Usage:
        from src.config.master_config import config
        
        print(config.database.postgres_url)
        print(config.paths.output_dir)
        print(config.api.ollama_host)
    """
    
    def __init__(self):
        self.database = DatabaseConfig()
        self.paths = PathConfig()
        self.api = APIConfig()
        self.app = ApplicationConfig()
        
        # Ensure all directories exist
        self.paths.ensure_directories()
    
    def to_dict(self) -> Dict[str, Any]:
        """Export all configuration as dictionary."""
        return {
            "database": self.database.dict(),
            "paths": {k: str(v) for k, v in self.paths.dict().items()},
            "api": self.api.dict(),
            "app": self.app.dict()
        }
    
    def validate(self) -> Dict[str, list]:
        """
        Validate all configuration and return issues.
        
        Returns:
            Dictionary with 'errors' and 'warnings' lists
        """
        errors = []
        warnings = []
        
        # Check critical files exist
        if not self.api.youtube_client_secrets.exists():
            errors.append(
                f"YouTube client secrets not found: {self.api.youtube_client_secrets}"
            )
        
        # Check database connections (would need actual connection test)
        # This is a placeholder
        if not self.database.postgres_password:
            warnings.append("PostgreSQL password not set")
        
        # Check API keys
        if not self.api.pexels_api_key:
            warnings.append("Pexels API key not set")
        
        if not self.api.pixabay_api_key:
            warnings.append("Pixabay API key not set")
        
        # Check Ollama availability (would need actual connection test)
        # Placeholder
        
        return {
            "errors": errors,
            "warnings": warnings
        }


# Global configuration instance
config = MasterConfig()


# Convenience function
def get_config() -> MasterConfig:
    """Get global configuration instance."""
    return config
3.2 Create .env Template
File: .env.example
bash# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=your_password_here
DB_NAME=faceless_youtube

MONGO_HOST=localhost
MONGO_PORT=27017
MONGO_DB=faceless_youtube

REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0

# API Configuration
API_HOST=0.0.0.0
API_PORT=8000
API_WORKERS=4

FRONTEND_PORT=3000

# External APIs
PEXELS_API_KEY=your_pexels_key
PIXABAY_API_KEY=your_pixabay_key

OLLAMA_HOST=localhost
OLLAMA_PORT=11434
OLLAMA_MODEL=mistral

# Optional APIs
OPENAI_API_KEY=
ELEVENLABS_API_KEY=

# YouTube
YOUTUBE_CLIENT_SECRETS=client_secrets.json

# Application
DEBUG=false
SECRET_KEY=generate_secure_key_here
CORS_ORIGINS=http://localhost:3000,http://localhost:8000

# Performance
MAX_CONCURRENT_JOBS=2
CACHE_TTL=3600

📋 TASK 4: CRITICAL ISSUE IDENTIFICATION [TASK-ISSUES-004]
4.1 Run Diagnostic Tests
Create: scripts/diagnostics.py
python"""
System Diagnostics Script
Checks all critical components for issues.
"""

import asyncio
import sys
from pathlib import Path
from typing import List, Dict, Any

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from src.config.master_config import config


class DiagnosticResult:
    """Stores diagnostic test results."""
    
    def __init__(self, component: str):
        self.component = component
        self.passed: List[str] = []
        self.failed: List[str] = []
        self.warnings: List[str] = []
    
    def add_pass(self, test: str):
        self.passed.append(test)
    
    def add_fail(self, test: str, error: str):
        self.failed.append(f"{test}: {error}")
    
    def add_warning(self, test: str, message: str):
        self.warnings.append(f"{test}: {message}")
    
    def is_healthy(self) -> bool:
        return len(self.failed) == 0
    
    def print_results(self):
        print(f"\n{'='*60}")
        print(f"Component: {self.component}")
        print(f"{'='*60}")
        
        if self.passed:
            print(f"\n✅ PASSED ({len(self.passed)}):")
            for test in self.passed:
                print(f"   {test}")
        
        if self.warnings:
            print(f"\n⚠️  WARNINGS ({len(self.warnings)}):")
            for warning in self.warnings:
                print(f"   {warning}")
        
        if self.failed:
            print(f"\n❌ FAILED ({len(self.failed)}):")
            for failure in self.failed:
                print(f"   {failure}")
        
        status = "HEALTHY ✅" if self.is_healthy() else "UNHEALTHY ❌"
        print(f"\nStatus: {status}\n")


async def test_database_connections():
    """Test all database connections."""
    result = DiagnosticResult("Database Connections")
    
    # PostgreSQL
    try:
        from sqlalchemy import create_engine
        engine = create_engine(config.database.postgres_url)
        with engine.connect() as conn:
            conn.execute("SELECT 1")
        result.add_pass("PostgreSQL connection")
    except Exception as e:
        result.add_fail("PostgreSQL connection", str(e))
    
    # MongoDB
    try:
        from pymongo import MongoClient
        client = MongoClient(config.database.mongodb_url, serverSelectionTimeoutMS=5000)
        client.server_info()
        result.add_pass("MongoDB connection")
    except Exception as e:
        result.add_fail("MongoDB connection", str(e))
    
    # Redis
    try:
        import redis
        r = redis.Redis(
            host=config.database.redis_host,
            port=config.database.redis_port,
            db=config.database.redis_db
        )
        r.ping()
        result.add_pass("Redis connection")
    except Exception as e:
        result.add_fail("Redis connection", str(e))
    
    return result


async def test_api_dependencies():
    """Test external API availability."""
    result = DiagnosticResult("External APIs")
    
    # Ollama
    try:
        import httpx
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"http://{config.api.ollama_host}:{config.api.ollama_port}/api/tags"
            )
            if response.status_code == 200:
                result.add_pass("Ollama connection")
            else:
                result.add_fail("Ollama connection", f"Status {response.status_code}")
    except Exception as e:
        result.add_fail("Ollama connection", str(e))
    
    # API Keys
    if config.api.pexels_api_key:
        result.add_pass("Pexels API key configured")
    else:
        result.add_warning("Pexels API key", "Not configured")
    
    if config.api.pixabay_api_key:
        result.add_pass("Pixabay API key configured")
    else:
        result.add_warning("Pixabay API key", "Not configured")
    
    # YouTube credentials
    if config.api.youtube_client_secrets.exists():
        result.add_pass("YouTube client secrets found")
    else:
        result.add_fail("YouTube client secrets", "File not found")
    
    return result


async def test_file_system():
    """Test file system setup."""
    result = DiagnosticResult("File System")
    
    # Check critical directories
    dirs_to_check = [
        ("Assets directory", config.paths.assets_dir),
        ("Output directory", config.paths.output_dir),
        ("Temp directory", config.paths.temp_dir),
        ("Cache directory", config.paths.cache_dir),
        ("Scripts directory", config.paths.scripts_dir),
    ]
    
    for name, path in dirs_to_check:
        if path.exists():
            result.add_pass(f"{name} exists: {path}")
        else:
            result.add_warning(f"{name}", f"Creating: {path}")
            path.mkdir(parents=True, exist_ok=True)
    
    # Check write permissions
    try:
        test_file = config.paths.temp_dir / "test_write.txt"
        test_file.write_text("test")
        test_file.unlink()
        result.add_pass("Write permissions OK")
    except Exception as e:
        result.add_fail("Write permissions", str(e))
    
    return result


async def test_python_imports():
    """Test critical Python imports."""
    result = DiagnosticResult("Python Dependencies")
    
    required_modules = [
        "fastapi",
        "uvicorn",
        "sqlalchemy",
        "pydantic",
        "redis",
        "pymongo",
        "httpx",
        "moviepy",
        "PIL",
        "google.oauth2",
    ]
    
    for module in required_modules:
        try:
            __import__(module)
            result.add_pass(f"Import {module}")
        except ImportError as e:
            result.add_fail(f"Import {module}", str(e))
    
    return result


async def test_services():
    """Test service availability."""
    result = DiagnosticResult("Application Services")
    
    # Test each service can be imported
    services = [
        "src.services.script_generator",
        "src.services.video_assembler",
        "src.services.youtube_uploader",
        "src.services.scheduler",
    ]
    
    for service in services:
        try:
            __import__(service)
            result.add_pass(f"Import {service}")
        except Exception as e:
            result.add_fail(f"Import {service}", str(e))
    
    return result


async def run_all_diagnostics():
    """Run all diagnostic tests."""
    print("\n" + "="*60)
    print("SYSTEM DIAGNOSTICS - FACELESS YOUTUBE AUTOMATION")
    print("="*60)
    
    results = []
    
    # Run all tests
    tests = [
        test_python_imports(),
        test_file_system(),
        test_database_connections(),
        test_api_dependencies(),
        test_services(),
    ]
    
    for test_result in await asyncio.gather(*tests):
        test_result.print_results()
        results.append(test_result)
    
    # Overall summary
    print("="*60)
    print("OVERALL SUMMARY")
    print("="*60)
    
    total_passed = sum(len(r.passed) for r in results)
    total_warnings = sum(len(r.warnings) for r in results)
    total_failed = sum(len(r.failed) for r in results)
    
    healthy_components = sum(1 for r in results if r.is_healthy())
    total_components = len(results)
    
    print(f"\nComponents: {healthy_components}/{total_components} healthy")
    print(f"Tests Passed: {total_passed}")
    print(f"Warnings: {total_warnings}")
    print(f"Tests Failed: {total_failed}")
    
    if total_failed == 0:
        print("\n✅ SYSTEM READY FOR PACKAGING\n")
        return 0
    else:
        print("\n❌ CRITICAL ISSUES MUST BE RESOLVED\n")
        return 1


if __name__ == "__main__":
    exit_code = asyncio.run(run_all_diagnostics())
    sys.exit(exit_code)
Run diagnostics:
bashpython scripts/diagnostics.py > diagnostic_report.txt

📋 TASK 5: CREATE UNIFIED STARTUP SYSTEM [TASK-STARTUP-005]
5.1 Cross-Platform Startup Script
File: start.py
python"""
Unified Startup Script
Starts all services with a single command.
"""

import subprocess
import sys
import time
import os
import signal
from pathlib import Path
from typing import List, Optional
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class ServiceManager:
    """Manages all application services."""
    
    def __init__(self):
        self.processes: List[subprocess.Popen] = []
        self.project_root = Path(__file__).parent
    
    def start_database_services(self):
        """Start database services (PostgreSQL, MongoDB, Redis)."""
        logger.info("Starting database services...")
        
        # Check if running in Docker or need to start locally
        # This is a placeholder - actual implementation depends on setup
        
        # PostgreSQL
        logger.info("✅ PostgreSQL (assumed running)")
        
        # MongoDB
        logger.info("✅ MongoDB (assumed running)")
        
        # Redis
        logger.info("✅ Redis (assumed running)")
    
    def start_backend(self):
        """Start FastAPI backend server."""
        logger.info("Starting FastAPI backend...")
        
        # Start uvicorn
        backend_cmd = [
            sys.executable, "-m", "uvicorn",
            "src.api.main:app",
            "--host", "0.0.0.0",
            "--port", "8000",
            "--reload"
        ]
        
        process = subprocess.Popen(
            backend_cmd,
            cwd=self.project_root,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        self.processes.append(process)
        logger.info("✅ Backend started on http://localhost:8000")
        
        # Wait for backend to be ready
        time.sleep(3)
    
    def start_frontend(self):
        """Start React frontend development server."""
        logger.info("Starting React frontend...")
        
        dashboard_dir = self.project_root / "dashboard"
        
        # Check if node_modules exists
        if not (dashboard_dir / "node_modules").exists():
            logger.info("Installing frontend dependencies...")
            subprocess.run(["npm", "install"], cwd=dashboard_dir, check=True)
        
        # Start Vite dev server
        frontend_cmd = ["npm", "run", "dev"]
        
        process = subprocess.Popen(
            frontend_cmd,
            cwd=dashboard_dir,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        self.processes.append(process)
        logger.info("✅ Frontend started on http://localhost:3000")
    
    def start_all(self):
        """Start all services."""
        try:
            self.start_database_services()
            self.start_backend()
            self.start_frontend()
            
            logger.info("\n" + "="*60)
            logger.info("🚀 ALL SERVICES STARTED")
            logger.info("="*60)
            logger.info("\nAccess points:")
            logger.info("  - Frontend: http://localhost:3000")
            logger.info("  - Backend API: http://localhost:8000")
            logger.info("  - API Docs: http://localhost:8000/docs")
            logger.info("\nPress Ctrl+C to stop all services\n")
            
            # Wait for interrupt
            self.wait_for_interrupt()
            
        except Exception as e:
            logger.error(f"Failed to start services: {e}")
            self.stop_all()
            sys.exit(1)
    
    def wait_for_interrupt(self):
        """Wait for keyboard interrupt."""
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            logger.info("\n\nShutting down services...")
            self.stop_all()
    
    def stop_all(self):
        """Stop all running services."""
        for process in self.processes:
            try:
                process.terminate()
                process.wait(timeout=5)
            except:
                process.kill()
        
        logger.info("✅ All services stopped")


def main():
    """Main entry point."""
    manager = ServiceManager()
    manager.start_all()


if __name__ == "__main__":
    main()
5.2 Windows Batch Launcher
File: start.bat
batch@echo off
echo ================================================
echo Faceless YouTube Automation Platform
echo ================================================
echo.
echo Starting all services...
echo.

REM Activate virtual environment if exists
if exist venv\Scripts\activate.bat (
    call venv\Scripts\activate.bat
)

REM Run Python startup script
python start.py

pause
5.3 Linux/Mac Shell Launcher
File: start.sh
bash#!/bin/bash

echo "================================================"
echo "Faceless YouTube Automation Platform"
echo "================================================"
echo ""
echo "Starting all services..."
echo ""

# Activate virtual environment if exists
if [ -f venv/bin/activate ]; then
    source venv/bin/activate
fi

# Run Python startup script
python start.py
bashchmod +x start.sh

📋 DELIVERABLES FOR THIS PHASE [DELIVERABLES-006]
After completing all tasks above, provide:
1. PROJECT_INVENTORY.md
Complete directory structure and file listing
2. dependency_audit.md
Full dependency analysis with issues flagged
3. src/config/master_config.py
Consolidated configuration system
4. .env.example
Environment variable template
5. scripts/diagnostics.py
Automated diagnostic tool
6. diagnostic_report.txt
Full system diagnostic results
7. start.py + start.bat + start.sh
Unified startup system
8. ISSUES_FOUND.md
Comprehensive list of all bugs, missing components, and integration failures discovered
Format:
markdown# CRITICAL ISSUES (Must fix before packaging)
1. [Issue description]
   - Location: [file/component]
   - Error: [error message]
   - Impact: [what breaks]
   - Suggested fix: [how to fix]

# WARNINGS (Should fix)
1. [Issue description]
   ...

# RECOMMENDATIONS (Nice to have)
1. [Improvement suggestion]
   ...

🎯 SUCCESS CRITERIA [SUCCESS-007]
Phase 1 is complete when:

 All project files inventoried
 All dependencies audited
 Master configuration system implemented
 Diagnostic script runs successfully
 Unified startup script created
 Comprehensive issues list generated
 Critical issues count: [NUMBER]
 Diagnostic pass rate: >80%


💬 COMMUNICATION PROTOCOL [COMM-008]
Progress Updates
After each task, report:
markdown✅ COMPLETED: [Task Name]
📊 Results:
- Files created: [COUNT]
- Issues found: [COUNT]
- Status: [OK/WARNING/ERROR]

📁 Artifacts:
- [file1.md]
- [file2.py]

🔜 Next: [Next task]

❓ Questions: [Any blockers or clarifications needed]
Blocker Reports
If blocked:
markdown🚫 BLOCKED: [Task Name]
❌ Issue: [Description]
🔍 Attempted: [What you tried]
🆘 Need: [Specific help required]

🚀 BEGIN EXECUTION
Start with TASK 1 and work sequentially. This phase lays the foundation for successful packaging in Phase 2.
Report back when Phase 1 is complete with all deliverables.

END OF PHASE 1 DIRECTIVE
</artifact>